우리는 화면에 보이는 글자를 ‘한 글자’로 인식한다.

하지만 컴퓨터에게 글자는 단순한 그림이 아니라 수많은 숫자들의 조합이다.

그렇기에 눈에 보이는 것과 내부에서 계산되는 값 사이에는 생각보다 큰 차이가 있다.

이모지는 그 차이를 가장 극적으로 드러낸다.

이번 글에서는, 우리가 “한 글자”라고 생각하는 이모지가 왜 컴퓨터에게는 여러 글자로 보이는지를 살펴본다

## 문제 발생

서비스의 QA를 진행하는 도중, 팀원 중 한 명이 input에 이모지를 입력할 시에 길이가 2개 내지는 3개까지 인식되는 것을 발견했다.

> 1. 이모지는 왜 한 글자가 아닌 여러 글자로 인식될까?
> 2. 이를 해결하기 위해 어떤 방식을 도입해 볼 수 있을까?  

위 주제에 대해 파고들어본 내용을 글로 남겨보려고 한다

---

## 1️⃣ 컴퓨터에서 문자가 처리되는 방식

브라우저에서 계산되는 문자열의 길이는 사용자가 눈으로 보는 ‘글자 수’가 아니라, 더 작은 단위인 “코드 유닛”을 기준으로 측정된다.

이 때문에 이모지가 여러 글자로 인식되는 현상이 발생한다.

따라서, 이런 동작을 이해하기 위해서는먼저 **코드 포인트(code point)** 와 **코드 유닛(code unit)** 의 개념,

그리고 문자가 실제로 어떤 방식으로 **인코딩(encoding)** 되는지를 살펴볼 필요가 있다.

### 코드포인트와 코드 유닛

컴퓨터는 문자 자체를 이해하지 못한다. "가" 라는 글자는 컴퓨터 입장에서는 오직 도형일 뿐이다.

결국, 각 문자를 0과 1로 변환하여 컴퓨터가 글자를 인식할 수 있도록 인코딩 하는 과정이 필요하다.

**1단계 : 코드포인트 매핑**

우선 각 문자는 코드포인트라는 숫자를 하나씩 부여받는다.

이 과정에서 각 언어의 문자에 임의로 숫자를 부여하면 혼란이 생기기 때문에, 이를 통일할 수 있는 하나의 규칙이 필요하다.

이 규칙 역할을 하는 것이 “유니코드”이다. 유니코드는 모든 문자 마다 고유한 코드 포인트 **하나**를 부여한다.

| **문자** | **코드포인트** |
| --- | --- |
| A | 0x0041 |
| 가 | 0xAC00 |
| … | … |

**2단계 : 코드 유닛 인코딩**

부여된 각 코드 포인트는 실제 컴퓨터가 이해할 수 있는 0과 1의 바이트 배열로 변환된다. 이 과정을 ‘인코딩(encoding)’이라고 한다.

브라우저는 인코딩시에 UTF(Unicode Transformation Format) 라는 방식을 사용한다. 이 때, 문자를 저장하는 단위에 따라 UTF-8, UTF-16 등으로 나뉘게 된다. UTF-8을 통해 인코딩 방식 예시를 들어보도록 한다.

UTF-8은 이름 그대로 8비트(1바이트) 를 기본 단위로 인코딩을 수행한다.

-   1바이트는 10진수 기준으로 0~127(2⁸−1) 사이의 수를 표현할 수 있다.
-   위 범위를 16진수로 계산해보면 0x00부터 0x7F의 숫자까지 표현할 수 있다.
-   코드 포인트로 기준으로, **U+0000부터 U+007F**를 표현할 수 있다는 것과 동일하다.

**표1) UTF-8 인코딩 구간별 코드 유닛 구성표**

| **인코딩 에 필요한 바이트 수** |  **표현 가능한 10진수 범위** |  **표현 가능한 16진수 범위**  | **코드 포인트 범위** |
| --- | --- | --- | --- |
| 1바이트 (8bit) | 0 ~ 127 | 0x00 ~ 0x7F | U+0000 ~ U+007F |
| 2바이트 (16bit) | 128 ~ 2,047 | 0x0080 ~ 0x07FF | U+0080 ~ U+07FF |
| 3바이트 (24bit) | 2,048 ~ 65,535 | 0x0800 ~ 0xFFFF | U+0800 ~ U+FFFF |
| 4바이트 (32bit) | 65,536 ~ 1,114,111 | 0x010000 ~ 0x10FFFF | U+10000 ~ U+10FFFF |

브라우저에서 자바스크립트 문자열을 내부적으로 표현할 때는 UTF-16 이 사용된다. 즉, 16비트를 기준 단위로 하여 인코딩을 한다. 위에 제시된 표를 16비트를 기준으로 계산해보면 된다.

**표2) UTF-16 인코딩 구간별 코드 유닛 구성표**

인코딩에 필요한 코드 유닛 수  범위 1 코드 포인트 범위

| **인코딩 에 필요한 바이트 수** | **표현 가능한 10진수 범위** | **표현 가능한 16진수 범위** | **코드 포인트 범위** |
| --- | --- | --- | --- |
| 1개 (16bit, 2바이트) | 0 ~ 55,295 | 0x0000 ~ 0xD7FF | U+0000 ~ U+D7FF |
| 사용 불가 (서러게이트 영역, 추후 설명) | — | 0xD800 ~ 0xDFFF | U+D800 ~ U+DFFF |
| 1개 (16bit, 2바이트) | 57,344 ~ 65,535 | 0xE000 ~ 0xFFFF | U+E000 ~ U+FFFF |
| 2개 (32bit, 4바이트) | 65,536 ~ 1,114,111 | 0x010000 ~ 0x10FFFF | U+10000 ~ U+10FFFF |

"가"라는 글자를 통해 인코딩 예시를 들어보려고 한다.

"가"의 코드포인트는 U+AC00로 (10진수 기준 44032)  U+0000 ~ U+D7FF 범위에 있다. 즉, UTF-16 기준 하나의 코드 유닛으로 표현이 가능하다.

**표3) "가"의 UTF-16 인코딩 예시표**

| 인코딩 방식 | "가" 의 코드포인트 | 코드 포인트 범위 | 코드 유닛 크기 | 코드 유닛 개수 | 총 바이트 수 |
| --- | --- | --- | --- | --- | --- |
| UTF-16 | 0xAC00 | U+0000 ~ U+D7FF   (표2 참조) | 16bit (2바이트) | 1개 | 2바이트 |

대부분의 글자 (영어, 한글) 등은 UTF-16 방식에서 하나의 코드유닛 (16bit)로 표현이 가능하다. 대부분의 문자들이 16bit 크기의 코드유닛 하나로 표현이 가능한 U+0000~ U+D7FF 사이의 코드 포인트를 가지기 때문이다.

---

## 2️⃣ 이모지의 코드 유닛 개수는?

이모지는 코드 포인트가 어떻게 될까?

또 몇 개의 코드 유닛을 가질까?

### 이모지는 몇 개의 코드 유닛을 가질까?

대부분의 이모지는 코드 포인트가 U+10000 이상으로 매우 큰 영역에 속한다.

이처럼 UTF-16에서 1코드유닛 (16bit = 2byte)으로 표현할 수 있는 범위인 U+0000~U+FFFF 밖의 문자를 표현하기 위해선 **서러게이트 페어**라는 방식을 사용한다.

간단하게 말하면, 16bit의 코드 유닛 2개가 합쳐져 하나의 문자를 이루는 것이다.

> 💬**\[예시\] 😀**  
> 😀의 코드포인트는 U+1F600, 16bit를 기준으로 구간을 나눴을 때, 다음 구간에 해당한다  
> **U+10000 ~ U+10FFFF**

UTF-16 기준, U+FFFF까지는 1코드 유닛으로 직접 표현 가능하다.

2코드 유닛 시작점인 U+10000을 빼는 연산을 통해, 표현이 가능한 영역의 이후 영역을 0부터 다시 표현한다.

**0x1F600** (😀의 코드포인트) **\- 0x10000**(2코드 유닛으로 표현하는 시작점) **\= 0xF600** (10진수 62976)

위 연산의 결과값은 U+0000~U+FFFF 사이에 포함된다. 즉, 해당 이모지는 2개의 코드 유닛으로 표현이 가능하다. 이 2개의 코드 유닛을 합쳐서 서러게이트 페어를 구성하여 표현한다.

---

이 때 각 코드 유닛은 16비트의 크기이지만 그 안에서 10비트씩만을 사용해 서러게이트 페어를 구성한다.

결론적으로, 이모지는 2개의 코드 유닛으로 표현되며 하나의 코드 유닛 안에서 10비트씩만을 사용한다.

U+10000 ~ U+10FFFF 범위 자체가 약 1,048,576개 문자(= 20비트)만 있으면 표현이 가능하기 때문이다.

나머지 6비트는 태그로써, “나는 서러게이트다”라는 표시용으로 쓰인다. 덕분에 일반 BMP 문자와 서러게이트 구간 문자를 구분할 수 있다.

### 길이가 2 이상인 이모지

길이가 2 이상으로 인식되는 이모지도 있다. 이 이모지들은 "조합" 방식을 사용한다.

이는 여러 코드 포인트를 합쳐서 하나의 문자로 표현한 것이다.

ZWJ 라는 연결자를 사용하는데, 여러 이모지를 "붙이는" 역할을 한다. ZWJ는 접착제고, 접착제의 길이가 1이라고 생각하면 된다.

예를 들면 다음과 같다

> **예시1) 🧑‍💻 = 👦 +ZWJ(1) + 💻**  
> **총 2개의 코드 유닛 (서러게이터 페어, 각 10bit씩 사용 중) + 1개의 ZWJ**  
> 브라우저 상에서 인식되는 총 길이 : 2 x 2 + 1 = 5 "🧑‍💻".length === 5  
>   
> **예시2) 👨‍👩‍👧‍👦 = 👨 + ZWJ + 👩 + ZWJ + 👧 + ZWJ + 👦  
> 총 4개의 코드유닛 + 3개의 ZWJ**  
> 브라우저 상에서 인식되는 총 길이 : 2 x 4 + 1 x 3 = 11  
> "👨‍👩‍👧‍👦".length === 11

## 3️⃣ 결론 : 왜 이모지는 2개 이상으로 인식되는 경우가 많을까?

**앞서 말했듯, 브라우저가 인식하는 것은 코드유닛의 개수이다. 즉, 사람 눈에 보이는 글자수가 아니다.**

자바스크립트(브라우저)는 문자열을 UTF-16 코드 유닛 배열로 다룬다.

.length는 코드 포인트(사람 눈에 보이는 글자 수)가 아니라 코드 유닛 개수를 반환하는 것이다.

따라서 이모지의 길이는 .length === 2 또는 그 이상으로 연산한다.

## 4️⃣ 해결책

결국, 사용자에겐 눈에 보이는 글자의 길이(grapheme)를 연산하여 보여주고 싶다면 글자 단위로 길이를 계산해야 한다. 이때 시도할 수 있는 방법은 다음과 같다

### Intl.Segmenter (브라우저 내장 API)

-   ECMAScript 국제화 API(ECMA-402)에서 제공하는 기능으로, 문자열을 그래프 클러스터(grapheme) 단위로 분리할 수 있다.
-   다만, 구형 브라우저에서는 지원하지 않는다는 단점이 있다.

```
const segmenter = new Intl.Segmenter("ko", { granularity: "grapheme" });
const input = "🧑‍💻👨‍👩‍👧‍👦"
const segments = [...segmenter.segment(input)]; // ["🧑‍💻", "👨‍👩‍👧‍👦"]
console.log(segments.length); // 2

```

"ko"는 언어(locale)를 지정한 것인데, 여기서는 한국어 기준으로 분리 규칙을 적용하라는 의미이다. 다만 grapheme 모드에서는 언어별로 큰 차이는 없다.

1.  segmenter.segment(input) → 문자열을 grapheme 단위 iterable로 반환한다
2.  segments.length로 눈에 보이는 문자 수를 계산할 수 있다

### Grapheme Splitter (외부 라이브러리)

```
import GraphemeSplitter from "grapheme-splitter";

const splitter = new GraphemeSplitter();

const input = "🧑‍💻👨‍👩‍👧‍👦";
const graphemes = splitter.splitGraphemes(input);

console.log(graphemes); // ["🧑‍💻", "👨‍👩‍👧‍👦"]
console.log(graphemes.length); // 2

```

1.  new GraphemeSplitter()로 글자를 grapheme 단위로 쪼개줄 분리자(splitter)를 생성한다
2.  splitGraphemes 메서드에 문자열을 넣으면, 사람 눈에 보이는 문자(grapheme) 단위로 나눈 배열을 반환한다.
3.  배열의 길이를 세면 실제 사용자가 눈으로 인식하는 문자의 개수를 정확히 얻을 수 있다.

## ✅ 결론

이모지가 여러 글자로 인식되는 이유는 자바스크립트가 문자열을 UTF-16 코드 유닛 배열로 처리하기 때문이며, 이를 해결하기 위해서는 사람 눈에 보이는 문자 단위(grapheme)로 세어야 한다.

최신 브라우저라면 Intl.Segmenter, 그 외 환경에서는 Grapheme Splitter 같은 라이브러리를 활용하면 된다.

[##_Image|kage@AMEfJ/btsQ59ZA6SJ/AAAAAAAAAAAAAAAAAAAAAO6GroRTZVvR-oS6_wjYaoJm8NvgZwsU-gzeSj6AnVs2/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1761922799&amp;allow_ip=&amp;allow_referer=&amp;signature=BtdkQP1vn9tOO5An2UvUaTLnOGs%3D|CDM|1.3|{"originWidth":1280,"originHeight":1059,"style":"alignCenter","caption":"정리표"}_##]